<?php
/**
 * TopicsApi
 * PHP version 7.3
 *
 * @category Class
 * @package  InfinityFree\DiscourseApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Discourse API Documentation
 *
 * This page contains the documentation on how to use Discourse through API calls.  > Note: For any endpoints not listed you can follow the [reverse engineer the Discourse API](https://meta.discourse.org/t/-/20576) guide to figure out how to use an API endpoint.  ### Request Content-Type  The Content-Type for POST and PUT requests can be set to `application/x-www-form-urlencoded`, `multipart/form-data`, or `application/json`.  ### Endpoint Names and Response Content-Type  Most API endpoints provide the same content as their HTML counterparts. For example the URL `/categories` serves a list of categories, the `/categories.json` API provides the same information in JSON format.  Instead of sending API requests to `/categories.json` you may also send them to `/categories` and add an `Accept: application/json` header to the request to get the JSON response. Sending requests with the `Accept` header is necessary if you want to use URLs for related endpoints returned by the API, such as pagination URLs. These URLs are returned without the `.json` prefix so you need to add the header in order to get the correct response format.  ### Authentication  Some endpoints do not require any authentication, pretty much anything else will require you to be authenticated.  To become authenticated you will need to create an API Key from the admin panel.  Once you have your API Key you can pass it in along with your API Username as an HTTP header like this:  ``` curl -X GET \"http://127.0.0.1:3000/admin/users/list/active.json\" \\ -H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\ -H \"Api-Username: system\" ```  and this is how POST requests will look:  ``` curl -X POST \"http://127.0.0.1:3000/categories\" \\ -H \"Content-Type: multipart/form-data;\" \\ -H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\ -H \"Api-Username: system\" \\ -F \"name=89853c20-4409-e91a-a8ea-f6cdff96aaaa\" \\ -F \"color=49d9e9\" \\ -F \"text_color=f0fcfd\" ```  ### Boolean values  If an endpoint accepts a boolean be sure to specify it as a lowercase `true` or `false` value unless noted otherwise.
 *
 * The version of the OpenAPI document: latest
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.3.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace InfinityFree\DiscourseApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use InfinityFree\DiscourseApi\ApiException;
use InfinityFree\DiscourseApi\Configuration;
use InfinityFree\DiscourseApi\HeaderSelector;
use InfinityFree\DiscourseApi\ObjectSerializer;

/**
 * TopicsApi Class Doc Comment
 *
 * @category Class
 * @package  InfinityFree\DiscourseApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TopicsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bookmarkTopic
     *
     * Bookmark topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function bookmarkTopic($apiKey, $apiUsername, $id)
    {
        $this->bookmarkTopicWithHttpInfo($apiKey, $apiUsername, $id);
    }

    /**
     * Operation bookmarkTopicWithHttpInfo
     *
     * Bookmark topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function bookmarkTopicWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $request = $this->bookmarkTopicRequest($apiKey, $apiUsername, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation bookmarkTopicAsync
     *
     * Bookmark topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bookmarkTopicAsync($apiKey, $apiUsername, $id)
    {
        return $this->bookmarkTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bookmarkTopicAsyncWithHttpInfo
     *
     * Bookmark topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bookmarkTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $returnType = '';
        $request = $this->bookmarkTopicRequest($apiKey, $apiUsername, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bookmarkTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bookmarkTopicRequest($apiKey, $apiUsername, $id)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling bookmarkTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling bookmarkTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling bookmarkTopic'
            );
        }

        $resourcePath = '/t/{id}/bookmark.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTopicPostPM
     *
     * Creates a new topic, a new post, or a private message
     *
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject11 $inlineObject11 inlineObject11 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20019
     */
    public function createTopicPostPM($inlineObject11 = null)
    {
        list($response) = $this->createTopicPostPMWithHttpInfo($inlineObject11);
        return $response;
    }

    /**
     * Operation createTopicPostPMWithHttpInfo
     *
     * Creates a new topic, a new post, or a private message
     *
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject11 $inlineObject11 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTopicPostPMWithHttpInfo($inlineObject11 = null)
    {
        $request = $this->createTopicPostPMRequest($inlineObject11);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20019' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20019', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20019';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTopicPostPMAsync
     *
     * Creates a new topic, a new post, or a private message
     *
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject11 $inlineObject11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicPostPMAsync($inlineObject11 = null)
    {
        return $this->createTopicPostPMAsyncWithHttpInfo($inlineObject11)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTopicPostPMAsyncWithHttpInfo
     *
     * Creates a new topic, a new post, or a private message
     *
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject11 $inlineObject11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicPostPMAsyncWithHttpInfo($inlineObject11 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20019';
        $request = $this->createTopicPostPMRequest($inlineObject11);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTopicPostPM'
     *
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject11 $inlineObject11 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTopicPostPMRequest($inlineObject11 = null)
    {

        $resourcePath = '/posts.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject11)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject11));
            } else {
                $httpBody = $inlineObject11;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTopicTimer
     *
     * Create topic timer
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject23 $inlineObject23 inlineObject23 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20041
     */
    public function createTopicTimer($apiKey, $apiUsername, $id, $inlineObject23 = null)
    {
        list($response) = $this->createTopicTimerWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject23);
        return $response;
    }

    /**
     * Operation createTopicTimerWithHttpInfo
     *
     * Create topic timer
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject23 $inlineObject23 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTopicTimerWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject23 = null)
    {
        $request = $this->createTopicTimerRequest($apiKey, $apiUsername, $id, $inlineObject23);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20041';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTopicTimerAsync
     *
     * Create topic timer
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject23 $inlineObject23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicTimerAsync($apiKey, $apiUsername, $id, $inlineObject23 = null)
    {
        return $this->createTopicTimerAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject23)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTopicTimerAsyncWithHttpInfo
     *
     * Create topic timer
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject23 $inlineObject23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicTimerAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject23 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20041';
        $request = $this->createTopicTimerRequest($apiKey, $apiUsername, $id, $inlineObject23);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTopicTimer'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject23 $inlineObject23 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTopicTimerRequest($apiKey, $apiUsername, $id, $inlineObject23 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling createTopicTimer'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling createTopicTimer'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createTopicTimer'
            );
        }

        $resourcePath = '/t/{id}/timer.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject23)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject23));
            } else {
                $httpBody = $inlineObject23;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSpecificPostsFromTopic
     *
     * Get specific posts from a topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject17 $inlineObject17 inlineObject17 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20034
     */
    public function getSpecificPostsFromTopic($apiKey, $apiUsername, $id, $inlineObject17 = null)
    {
        list($response) = $this->getSpecificPostsFromTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject17);
        return $response;
    }

    /**
     * Operation getSpecificPostsFromTopicWithHttpInfo
     *
     * Get specific posts from a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject17 $inlineObject17 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20034, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSpecificPostsFromTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject17 = null)
    {
        $request = $this->getSpecificPostsFromTopicRequest($apiKey, $apiUsername, $id, $inlineObject17);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20034' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20034', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20034';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSpecificPostsFromTopicAsync
     *
     * Get specific posts from a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject17 $inlineObject17 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecificPostsFromTopicAsync($apiKey, $apiUsername, $id, $inlineObject17 = null)
    {
        return $this->getSpecificPostsFromTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject17)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSpecificPostsFromTopicAsyncWithHttpInfo
     *
     * Get specific posts from a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject17 $inlineObject17 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSpecificPostsFromTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject17 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20034';
        $request = $this->getSpecificPostsFromTopicRequest($apiKey, $apiUsername, $id, $inlineObject17);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSpecificPostsFromTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject17 $inlineObject17 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSpecificPostsFromTopicRequest($apiKey, $apiUsername, $id, $inlineObject17 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling getSpecificPostsFromTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling getSpecificPostsFromTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSpecificPostsFromTopic'
            );
        }

        $resourcePath = '/t/{id}/posts.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject17)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject17));
            } else {
                $httpBody = $inlineObject17;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopic
     *
     * Get a single topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20035
     */
    public function getTopic($apiKey, $apiUsername, $id)
    {
        list($response) = $this->getTopicWithHttpInfo($apiKey, $apiUsername, $id);
        return $response;
    }

    /**
     * Operation getTopicWithHttpInfo
     *
     * Get a single topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $request = $this->getTopicRequest($apiKey, $apiUsername, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20035' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20035', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20035';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicAsync
     *
     * Get a single topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicAsync($apiKey, $apiUsername, $id)
    {
        return $this->getTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicAsyncWithHttpInfo
     *
     * Get a single topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20035';
        $request = $this->getTopicRequest($apiKey, $apiUsername, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTopicRequest($apiKey, $apiUsername, $id)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling getTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling getTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTopic'
            );
        }

        $resourcePath = '/t/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inviteToTopic
     *
     * Invite to topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject19 $inlineObject19 inlineObject19 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20037
     */
    public function inviteToTopic($apiKey, $apiUsername, $id, $inlineObject19 = null)
    {
        list($response) = $this->inviteToTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject19);
        return $response;
    }

    /**
     * Operation inviteToTopicWithHttpInfo
     *
     * Invite to topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject19 $inlineObject19 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function inviteToTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject19 = null)
    {
        $request = $this->inviteToTopicRequest($apiKey, $apiUsername, $id, $inlineObject19);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20037';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inviteToTopicAsync
     *
     * Invite to topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject19 $inlineObject19 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteToTopicAsync($apiKey, $apiUsername, $id, $inlineObject19 = null)
    {
        return $this->inviteToTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject19)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inviteToTopicAsyncWithHttpInfo
     *
     * Invite to topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject19 $inlineObject19 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inviteToTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject19 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20037';
        $request = $this->inviteToTopicRequest($apiKey, $apiUsername, $id, $inlineObject19);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inviteToTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject19 $inlineObject19 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inviteToTopicRequest($apiKey, $apiUsername, $id, $inlineObject19 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling inviteToTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling inviteToTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling inviteToTopic'
            );
        }

        $resourcePath = '/t/{id}/invite.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject19)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject19));
            } else {
                $httpBody = $inlineObject19;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLatestTopics
     *
     * Get the latest topics
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $order Enum: &#x60;default&#x60;, &#x60;created&#x60;, &#x60;activity&#x60;, &#x60;views&#x60;, &#x60;posts&#x60;, &#x60;category&#x60;, &#x60;likes&#x60;, &#x60;op_likes&#x60;, &#x60;posters&#x60; (optional)
     * @param  string $ascending Defaults to &#x60;desc&#x60;, add &#x60;ascending&#x3D;true&#x60; to sort asc (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20039
     */
    public function listLatestTopics($apiKey, $apiUsername, $order = null, $ascending = null)
    {
        list($response) = $this->listLatestTopicsWithHttpInfo($apiKey, $apiUsername, $order, $ascending);
        return $response;
    }

    /**
     * Operation listLatestTopicsWithHttpInfo
     *
     * Get the latest topics
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $order Enum: &#x60;default&#x60;, &#x60;created&#x60;, &#x60;activity&#x60;, &#x60;views&#x60;, &#x60;posts&#x60;, &#x60;category&#x60;, &#x60;likes&#x60;, &#x60;op_likes&#x60;, &#x60;posters&#x60; (optional)
     * @param  string $ascending Defaults to &#x60;desc&#x60;, add &#x60;ascending&#x3D;true&#x60; to sort asc (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLatestTopicsWithHttpInfo($apiKey, $apiUsername, $order = null, $ascending = null)
    {
        $request = $this->listLatestTopicsRequest($apiKey, $apiUsername, $order, $ascending);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20039';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLatestTopicsAsync
     *
     * Get the latest topics
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $order Enum: &#x60;default&#x60;, &#x60;created&#x60;, &#x60;activity&#x60;, &#x60;views&#x60;, &#x60;posts&#x60;, &#x60;category&#x60;, &#x60;likes&#x60;, &#x60;op_likes&#x60;, &#x60;posters&#x60; (optional)
     * @param  string $ascending Defaults to &#x60;desc&#x60;, add &#x60;ascending&#x3D;true&#x60; to sort asc (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLatestTopicsAsync($apiKey, $apiUsername, $order = null, $ascending = null)
    {
        return $this->listLatestTopicsAsyncWithHttpInfo($apiKey, $apiUsername, $order, $ascending)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLatestTopicsAsyncWithHttpInfo
     *
     * Get the latest topics
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $order Enum: &#x60;default&#x60;, &#x60;created&#x60;, &#x60;activity&#x60;, &#x60;views&#x60;, &#x60;posts&#x60;, &#x60;category&#x60;, &#x60;likes&#x60;, &#x60;op_likes&#x60;, &#x60;posters&#x60; (optional)
     * @param  string $ascending Defaults to &#x60;desc&#x60;, add &#x60;ascending&#x3D;true&#x60; to sort asc (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLatestTopicsAsyncWithHttpInfo($apiKey, $apiUsername, $order = null, $ascending = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20039';
        $request = $this->listLatestTopicsRequest($apiKey, $apiUsername, $order, $ascending);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLatestTopics'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $order Enum: &#x60;default&#x60;, &#x60;created&#x60;, &#x60;activity&#x60;, &#x60;views&#x60;, &#x60;posts&#x60;, &#x60;category&#x60;, &#x60;likes&#x60;, &#x60;op_likes&#x60;, &#x60;posters&#x60; (optional)
     * @param  string $ascending Defaults to &#x60;desc&#x60;, add &#x60;ascending&#x3D;true&#x60; to sort asc (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listLatestTopicsRequest($apiKey, $apiUsername, $order = null, $ascending = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling listLatestTopics'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling listLatestTopics'
            );
        }

        $resourcePath = '/latest.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($order !== null) {
            if('form' === 'form' && is_array($order)) {
                foreach($order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['order'] = $order;
            }
        }
        // query params
        if ($ascending !== null) {
            if('form' === 'form' && is_array($ascending)) {
                foreach($ascending as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ascending'] = $ascending;
            }
        }

        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTopTopics
     *
     * Get the top topics filtered by period
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $period Enum: &#x60;all&#x60;, &#x60;yearly&#x60;, &#x60;quarterly&#x60;, &#x60;monthly&#x60;, &#x60;weekly&#x60;, &#x60;daily&#x60; (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20040
     */
    public function listTopTopics($apiKey, $apiUsername, $period = null)
    {
        list($response) = $this->listTopTopicsWithHttpInfo($apiKey, $apiUsername, $period);
        return $response;
    }

    /**
     * Operation listTopTopicsWithHttpInfo
     *
     * Get the top topics filtered by period
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $period Enum: &#x60;all&#x60;, &#x60;yearly&#x60;, &#x60;quarterly&#x60;, &#x60;monthly&#x60;, &#x60;weekly&#x60;, &#x60;daily&#x60; (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTopTopicsWithHttpInfo($apiKey, $apiUsername, $period = null)
    {
        $request = $this->listTopTopicsRequest($apiKey, $apiUsername, $period);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20040' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20040', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20040';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTopTopicsAsync
     *
     * Get the top topics filtered by period
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $period Enum: &#x60;all&#x60;, &#x60;yearly&#x60;, &#x60;quarterly&#x60;, &#x60;monthly&#x60;, &#x60;weekly&#x60;, &#x60;daily&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTopTopicsAsync($apiKey, $apiUsername, $period = null)
    {
        return $this->listTopTopicsAsyncWithHttpInfo($apiKey, $apiUsername, $period)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTopTopicsAsyncWithHttpInfo
     *
     * Get the top topics filtered by period
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $period Enum: &#x60;all&#x60;, &#x60;yearly&#x60;, &#x60;quarterly&#x60;, &#x60;monthly&#x60;, &#x60;weekly&#x60;, &#x60;daily&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTopTopicsAsyncWithHttpInfo($apiKey, $apiUsername, $period = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20040';
        $request = $this->listTopTopicsRequest($apiKey, $apiUsername, $period);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTopTopics'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $period Enum: &#x60;all&#x60;, &#x60;yearly&#x60;, &#x60;quarterly&#x60;, &#x60;monthly&#x60;, &#x60;weekly&#x60;, &#x60;daily&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTopTopicsRequest($apiKey, $apiUsername, $period = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling listTopTopics'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling listTopTopics'
            );
        }

        $resourcePath = '/top.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($period !== null) {
            if('form' === 'form' && is_array($period)) {
                foreach($period as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['period'] = $period;
            }
        }

        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeTopic
     *
     * Remove a topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeTopic($apiKey, $apiUsername, $id)
    {
        $this->removeTopicWithHttpInfo($apiKey, $apiUsername, $id);
    }

    /**
     * Operation removeTopicWithHttpInfo
     *
     * Remove a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeTopicWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $request = $this->removeTopicRequest($apiKey, $apiUsername, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeTopicAsync
     *
     * Remove a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTopicAsync($apiKey, $apiUsername, $id)
    {
        return $this->removeTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeTopicAsyncWithHttpInfo
     *
     * Remove a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id)
    {
        $returnType = '';
        $request = $this->removeTopicRequest($apiKey, $apiUsername, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeTopicRequest($apiKey, $apiUsername, $id)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling removeTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling removeTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling removeTopic'
            );
        }

        $resourcePath = '/t/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setNotificationLevel
     *
     * Set notification level
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject21 $inlineObject21 inlineObject21 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20010
     */
    public function setNotificationLevel($apiKey, $apiUsername, $id, $inlineObject21 = null)
    {
        list($response) = $this->setNotificationLevelWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject21);
        return $response;
    }

    /**
     * Operation setNotificationLevelWithHttpInfo
     *
     * Set notification level
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject21 $inlineObject21 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function setNotificationLevelWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject21 = null)
    {
        $request = $this->setNotificationLevelRequest($apiKey, $apiUsername, $id, $inlineObject21);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20010' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20010', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20010';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setNotificationLevelAsync
     *
     * Set notification level
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject21 $inlineObject21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setNotificationLevelAsync($apiKey, $apiUsername, $id, $inlineObject21 = null)
    {
        return $this->setNotificationLevelAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject21)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setNotificationLevelAsyncWithHttpInfo
     *
     * Set notification level
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject21 $inlineObject21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setNotificationLevelAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject21 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20010';
        $request = $this->setNotificationLevelRequest($apiKey, $apiUsername, $id, $inlineObject21);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setNotificationLevel'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject21 $inlineObject21 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setNotificationLevelRequest($apiKey, $apiUsername, $id, $inlineObject21 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling setNotificationLevel'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling setNotificationLevel'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setNotificationLevel'
            );
        }

        $resourcePath = '/t/{id}/notifications.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject21)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject21));
            } else {
                $httpBody = $inlineObject21;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTopic
     *
     * Update a topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject18 $inlineObject18 inlineObject18 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20036
     */
    public function updateTopic($apiKey, $apiUsername, $id, $inlineObject18 = null)
    {
        list($response) = $this->updateTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject18);
        return $response;
    }

    /**
     * Operation updateTopicWithHttpInfo
     *
     * Update a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject18 $inlineObject18 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTopicWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject18 = null)
    {
        $request = $this->updateTopicRequest($apiKey, $apiUsername, $id, $inlineObject18);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20036';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTopicAsync
     *
     * Update a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject18 $inlineObject18 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicAsync($apiKey, $apiUsername, $id, $inlineObject18 = null)
    {
        return $this->updateTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject18)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTopicAsyncWithHttpInfo
     *
     * Update a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject18 $inlineObject18 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject18 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20036';
        $request = $this->updateTopicRequest($apiKey, $apiUsername, $id, $inlineObject18);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTopic'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject18 $inlineObject18 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTopicRequest($apiKey, $apiUsername, $id, $inlineObject18 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling updateTopic'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling updateTopic'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTopic'
            );
        }

        $resourcePath = '/t/-/{id}.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject18)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject18));
            } else {
                $httpBody = $inlineObject18;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTopicStatus
     *
     * Update the status of a topic
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject20 $inlineObject20 inlineObject20 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20038
     */
    public function updateTopicStatus($apiKey, $apiUsername, $id, $inlineObject20 = null)
    {
        list($response) = $this->updateTopicStatusWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject20);
        return $response;
    }

    /**
     * Operation updateTopicStatusWithHttpInfo
     *
     * Update the status of a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject20 $inlineObject20 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTopicStatusWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject20 = null)
    {
        $request = $this->updateTopicStatusRequest($apiKey, $apiUsername, $id, $inlineObject20);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20038';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTopicStatusAsync
     *
     * Update the status of a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject20 $inlineObject20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicStatusAsync($apiKey, $apiUsername, $id, $inlineObject20 = null)
    {
        return $this->updateTopicStatusAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject20)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTopicStatusAsyncWithHttpInfo
     *
     * Update the status of a topic
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject20 $inlineObject20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicStatusAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject20 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20038';
        $request = $this->updateTopicStatusRequest($apiKey, $apiUsername, $id, $inlineObject20);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTopicStatus'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject20 $inlineObject20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTopicStatusRequest($apiKey, $apiUsername, $id, $inlineObject20 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling updateTopicStatus'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling updateTopicStatus'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTopicStatus'
            );
        }

        $resourcePath = '/t/{id}/status.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject20)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject20));
            } else {
                $httpBody = $inlineObject20;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTopicTimestamp
     *
     * Update topic timestamp
     *
     * @param  string $apiKey apiKey (required)
     * @param  string $apiUsername apiUsername (required)
     * @param  string $id id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject22 $inlineObject22 inlineObject22 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \InfinityFree\DiscourseApi\Model\InlineResponse20010
     */
    public function updateTopicTimestamp($apiKey, $apiUsername, $id, $inlineObject22 = null)
    {
        list($response) = $this->updateTopicTimestampWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject22);
        return $response;
    }

    /**
     * Operation updateTopicTimestampWithHttpInfo
     *
     * Update topic timestamp
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject22 $inlineObject22 (optional)
     *
     * @throws \InfinityFree\DiscourseApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \InfinityFree\DiscourseApi\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTopicTimestampWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject22 = null)
    {
        $request = $this->updateTopicTimestampRequest($apiKey, $apiUsername, $id, $inlineObject22);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\InfinityFree\DiscourseApi\Model\InlineResponse20010' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\InfinityFree\DiscourseApi\Model\InlineResponse20010', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20010';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\InfinityFree\DiscourseApi\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTopicTimestampAsync
     *
     * Update topic timestamp
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject22 $inlineObject22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicTimestampAsync($apiKey, $apiUsername, $id, $inlineObject22 = null)
    {
        return $this->updateTopicTimestampAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject22)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTopicTimestampAsyncWithHttpInfo
     *
     * Update topic timestamp
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject22 $inlineObject22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicTimestampAsyncWithHttpInfo($apiKey, $apiUsername, $id, $inlineObject22 = null)
    {
        $returnType = '\InfinityFree\DiscourseApi\Model\InlineResponse20010';
        $request = $this->updateTopicTimestampRequest($apiKey, $apiUsername, $id, $inlineObject22);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTopicTimestamp'
     *
     * @param  string $apiKey (required)
     * @param  string $apiUsername (required)
     * @param  string $id (required)
     * @param  \InfinityFree\DiscourseApi\Model\InlineObject22 $inlineObject22 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTopicTimestampRequest($apiKey, $apiUsername, $id, $inlineObject22 = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null || (is_array($apiKey) && count($apiKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling updateTopicTimestamp'
            );
        }
        // verify the required parameter 'apiUsername' is set
        if ($apiUsername === null || (is_array($apiUsername) && count($apiUsername) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiUsername when calling updateTopicTimestamp'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTopicTimestamp'
            );
        }

        $resourcePath = '/t/{id}/change-timestamp.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($apiKey !== null) {
            $headerParams['Api-Key'] = ObjectSerializer::toHeaderValue($apiKey);
        }
        // header params
        if ($apiUsername !== null) {
            $headerParams['Api-Username'] = ObjectSerializer::toHeaderValue($apiUsername);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inlineObject22)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inlineObject22));
            } else {
                $httpBody = $inlineObject22;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
